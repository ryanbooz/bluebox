procedure "bluebox"."generate_rentals(timestamp with time zone, timestamp with time zone, boolean, numeric, numeric, numeric, integer, boolean)" {
  text = """

DECLARE
    v_cust_percent float;
    v_target_rentals int;
    v_active_customer_count int;
    v_interval_hours numeric;
    v_sample_pct numeric;
    v_rentals_created int;
BEGIN
    -- Validate inputs
    IF p_start_time >= p_end_time THEN
        RAISE EXCEPTION 'p_end_time must be after p_start_time';
    END IF;
    
    -- Calculate interval in hours
    v_interval_hours := EXTRACT(EPOCH FROM (p_end_time - p_start_time)) / 3600.0;
    
    IF v_interval_hours > 24 THEN
        RAISE EXCEPTION 'Maximum interval is 24 hours. For multi-day generation, use generate_rental_history() instead. Requested: % hours', v_interval_hours;
    END IF;
    
    -- Get active customer count
    SELECT count(*) INTO v_active_customer_count 
    FROM bluebox.customer WHERE activebool = TRUE;
    
    -- Calculate customer percentage (QUALIFIED)
    SELECT bluebox.random_between(p_min_cust_pct, p_max_cust_pct, 3) INTO v_cust_percent;
    
    -- Check for holidays - increase volume
    IF EXISTS (
        SELECT 1 FROM bluebox.holiday 
        WHERE holiday_date::timestamptz <@ tstzrange(p_start_time, p_end_time)
    ) THEN
        IF p_print_debug THEN
            RAISE NOTICE 'Holiday detected in range';
        END IF;
        SELECT bluebox.random_between(
            p_min_cust_pct * p_holiday_multiplier, 
            p_max_cust_pct * p_holiday_multiplier, 
            3
        ) INTO v_cust_percent;
    END IF;
    
    -- Calculate target rentals, scaled by interval
    v_target_rentals := GREATEST(1,
        (v_active_customer_count * v_cust_percent / 100 * v_interval_hours / 24)::int
    );
    
    -- Calculate TABLESAMPLE percentage (with buffer for filtering)
    v_sample_pct := GREATEST(0.001, LEAST(100, 
        (v_target_rentals * 1.5 / NULLIF(v_active_customer_count, 0) * 100)::numeric(10,4)
    ));
    
    IF p_print_debug THEN
        RAISE NOTICE 'Time range: % to % (% hours)', p_start_time, p_end_time, round(v_interval_hours::numeric, 2);
        RAISE NOTICE 'Active customers: %, Cust%%: %, Target rentals: %', 
            v_active_customer_count, round(v_cust_percent::numeric, 3), v_target_rentals;
        RAISE NOTICE 'Close rentals: %, Sample%%: %', p_close_rentals, v_sample_pct;
    END IF;

    -- Single unified CTE chain - behavior controlled by p_close_rentals
    WITH outstanding_rentals AS MATERIALIZED (
        SELECT customer_id, inventory_id 
        FROM bluebox.rental
        WHERE rental_period && tstzrange(p_start_time, p_end_time)
           -- For open rentals mode, also exclude customers with any open rental
           OR (NOT p_close_rentals AND upper(rental_period) IS NULL)
    ),
    
    rental_customers AS MATERIALIZED (
        SELECT c.customer_id, c.geog
        FROM bluebox.customer c TABLESAMPLE BERNOULLI(v_sample_pct)
        WHERE c.activebool = TRUE
          AND c.customer_id NOT IN (SELECT customer_id FROM outstanding_rentals)
        LIMIT v_target_rentals
    ),
    
    customer_stores AS MATERIALIZED (
        SELECT 
            c.customer_id,
            stores.rental_store_id,
            stores.return_store_id,
            row_number() OVER (PARTITION BY stores.rental_store_id ORDER BY random()) as store_rn
        FROM rental_customers c
        CROSS JOIN LATERAL (
            SELECT 
                store_ids[1] as rental_store_id,
                CASE 
                    WHEN p_close_rentals THEN COALESCE(store_ids[2], store_ids[1])
                    ELSE store_ids[1]
                END as return_store_id
            FROM (
                SELECT array_agg(s.store_id) as store_ids
                FROM (
                    SELECT store_id
                    FROM bluebox.store s
                    WHERE ST_DWithin(s.geog, c.geog, p_store_distance)
                    ORDER BY random()
                    LIMIT CASE WHEN p_close_rentals THEN 2 ELSE 1 END
                ) s
            ) sub
        ) stores
    ),
    
    matched_rentals AS MATERIALIZED (
        SELECT 
            cs.customer_id,
            cs.rental_store_id,
            cs.return_store_id,
            inv.inventory_id,
            p_start_time + (random() * v_interval_hours * 3600) * interval '1 second' as rental_start_time
        FROM customer_stores cs
        CROSS JOIN LATERAL (
            SELECT i.inventory_id
            FROM bluebox.inventory i
            INNER JOIN bluebox.film f USING(film_id)
            WHERE i.store_id = cs.rental_store_id
              AND i.status_id = 1
              AND i.inventory_id NOT IN (SELECT inventory_id FROM outstanding_rentals)
              AND f.release_date <= p_start_time::date
            ORDER BY random()
            LIMIT 1
        ) inv
    ),
    
    created_rentals AS (
        INSERT INTO bluebox.rental (rental_period, inventory_id, customer_id, store_id)
        SELECT 
            CASE 
                WHEN p_close_rentals THEN
                    tstzrange(
                        rental_start_time,
                        rental_start_time + ((random() * 62 + 10) * interval '1 hour')
                    )
                ELSE
                    tstzrange(rental_start_time, NULL)
            END,
            inventory_id,
            customer_id,
            rental_store_id
        FROM matched_rentals
        RETURNING rental_id, inventory_id
    ),
    
    inventory_updates AS (
        UPDATE bluebox.inventory i
        SET store_id = mr.return_store_id,
            last_update = now()
        FROM matched_rentals mr
        WHERE i.inventory_id = mr.inventory_id
          AND p_close_rentals
          AND mr.return_store_id IS DISTINCT FROM mr.rental_store_id
        RETURNING i.inventory_id
    )
    
    SELECT count(*) INTO v_rentals_created FROM created_rentals;
    
    IF p_print_debug THEN
        RAISE NOTICE 'Created % rentals (closed: %)', v_rentals_created, p_close_rentals;
    END IF;
    
    COMMIT;
    
    -- Generate payments for closed rentals
    IF p_close_rentals AND v_rentals_created > 0 THEN
        CALL bluebox.insert_payments(p_start_time::date);
        IF p_print_debug THEN
            RAISE NOTICE 'Payments generated for %', p_start_time::date;
        END IF;
    END IF;
END;
"""
  arguments = <
    {
      name = p_start_time
      type = timestamp with time zone
      mode = IN
      default = now()
    }

    {
      name = p_end_time
      type = timestamp with time zone
      mode = IN
      default = """-
(now() + '00:05:00'::interval)
"""
    }

    {
      name = p_close_rentals
      type = boolean
      mode = IN
      default = false
    }

    {
      name = p_min_cust_pct
      type = numeric
      mode = IN
      default = 0.8
    }

    {
      name = p_max_cust_pct
      type = numeric
      mode = IN
      default = 2.5
    }

    {
      name = p_holiday_multiplier
      type = numeric
      mode = IN
      default = 2.5
    }

    {
      name = p_store_distance
      type = integer
      mode = IN
      default = 25000
    }

    {
      name = p_print_debug
      type = boolean
      mode = IN
      default = false
    }

  >
  language = plpgsql
}

