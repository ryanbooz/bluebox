-- Script generated by Redgate Compare v1.48.1.2539
SET check_function_bodies = false;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.pricing...';END$$;
CREATE TABLE bluebox.pricing (
    pricing_key text NOT NULL,
    pricing_value numeric(10,2) NOT NULL,
    description text,
    effective_date date NOT NULL DEFAULT CURRENT_DATE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now()
);
ALTER TABLE bluebox.pricing ADD CONSTRAINT pricing_pkey PRIMARY KEY (pricing_key);
INSERT INTO bluebox.pricing(pricing_key, pricing_value, description, effective_date, created_at, updated_at) OVERRIDING SYSTEM VALUE VALUES
('daily_rental_rate', '1.99', 'Standard per-day rental charge', '2026-02-03', '2026-02-03 22:59:12.14719+00', '2026-02-03 22:59:12.14719+00'),
('replacement_cost_catalog', '14.99', 'Replacement cost for films 3-10 years old', '2026-02-03', '2026-02-03 22:59:12.14719+00', '2026-02-03 22:59:12.14719+00'),
('replacement_cost_classic', '9.99', 'Replacement cost for films 10+ years old', '2026-02-03', '2026-02-03 22:59:12.14719+00', '2026-02-03 22:59:12.14719+00'),
('replacement_cost_new', '24.99', 'Replacement cost for films < 1 year old', '2026-02-03', '2026-02-03 22:59:12.14719+00', '2026-02-03 22:59:12.14719+00'),
('replacement_cost_recent', '19.99', 'Replacement cost for films 1-3 years old', '2026-02-03', '2026-02-03 22:59:12.14719+00', '2026-02-03 22:59:12.14719+00')
ON CONFLICT (pricing_key) DO UPDATE SET pricing_value = EXCLUDED.pricing_value, description = EXCLUDED.description, effective_date = EXCLUDED.effective_date, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping bluebox.insert_single_payment(integer)...';END$$;
DROP PROCEDURE bluebox.insert_single_payment(integer);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping bluebox.generate_rental_history(timestamp with time zone, timestamp with time zone, numeric, numeric, double precision, integer, boolean)...';END$$;
DROP PROCEDURE bluebox.generate_rental_history(timestamp with time zone, timestamp with time zone, numeric, numeric, double precision, integer, boolean);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping bluebox.generate_new_rentals(interval, real, real, integer)...';END$$;
DROP PROCEDURE bluebox.generate_new_rentals(interval, real, real, integer);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping bluebox.generate_individual_rental(integer)...';END$$;
DROP PROCEDURE bluebox.generate_individual_rental(integer);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping bluebox.complete_recent_rentals(interval, integer)...';END$$;
DROP PROCEDURE bluebox.complete_recent_rentals(interval, integer);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.get_pricing(text)...';END$$;
CREATE FUNCTION bluebox.get_pricing(IN p_key text)
RETURNS numeric
LANGUAGE sql
STABLE
AS $_$
    SELECT pricing_value 
    FROM bluebox.pricing 
    WHERE pricing_key = p_key;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.get_replacement_cost(integer)...';END$$;
CREATE FUNCTION bluebox.get_replacement_cost(IN p_inventory_id integer)
RETURNS numeric
LANGUAGE sql
STABLE
AS $_$
    SELECT bluebox.get_replacement_cost(i.film_id)
    FROM bluebox.inventory i
    WHERE i.inventory_id = p_inventory_id;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.get_replacement_cost(bigint)...';END$$;
CREATE FUNCTION bluebox.get_replacement_cost(IN p_film_id bigint)
RETURNS numeric
LANGUAGE sql
STABLE
AS $_$
    SELECT CASE
        WHEN f.release_date > CURRENT_DATE - INTERVAL '1 year' 
            THEN bluebox.get_pricing('replacement_cost_new')
        WHEN f.release_date > CURRENT_DATE - INTERVAL '3 years' 
            THEN bluebox.get_pricing('replacement_cost_recent')
        WHEN f.release_date > CURRENT_DATE - INTERVAL '10 years' 
            THEN bluebox.get_pricing('replacement_cost_catalog')
        ELSE 
            bluebox.get_pricing('replacement_cost_classic')
    END
    FROM bluebox.film f
    WHERE f.film_id = p_film_id;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.get_daily_rental_rate(bigint)...';END$$;
CREATE FUNCTION bluebox.get_daily_rental_rate(IN p_film_id bigint DEFAULT NULL::bigint)
RETURNS numeric
LANGUAGE sql
STABLE
AS $_$
    SELECT bluebox.get_pricing('daily_rental_rate');
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.idx_pricing_key...';END$$;
CREATE INDEX idx_pricing_key ON bluebox.pricing USING btree (pricing_key);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.process_lost_rentals(interval, boolean)...';END$$;
CREATE PROCEDURE bluebox.process_lost_rentals(IN p_lost_after interval DEFAULT '30 days'::interval, IN p_print_debug boolean DEFAULT false)
LANGUAGE plpgsql
AS $_$
DECLARE
    v_lost_count int;
    v_payments_created int;
BEGIN
    WITH lost_rentals AS MATERIALIZED (
        SELECT 
            r.rental_id,
            r.customer_id,
            r.inventory_id,
            r.store_id,
            lower(r.rental_period) as rental_start,
            now() as loss_date
        FROM bluebox.rental r
        WHERE upper(r.rental_period) IS NULL
          AND lower(r.rental_period) < now() - p_lost_after
    ),
    
    closed_rentals AS (
        UPDATE bluebox.rental r
        SET rental_period = tstzrange(lower(r.rental_period), lr.loss_date)
        FROM lost_rentals lr
        WHERE r.rental_id = lr.rental_id
        RETURNING r.rental_id, r.inventory_id, r.customer_id, lr.loss_date
    ),
    
    lost_inventory AS (
        UPDATE bluebox.inventory i
        SET status_id = 2,  -- 'lost'
            last_update = now()
        FROM closed_rentals cr
        WHERE i.inventory_id = cr.inventory_id
        RETURNING i.inventory_id, i.film_id
    ),
    
    payment_info AS (
        SELECT 
            cr.rental_id,
            cr.customer_id,
            cr.loss_date as payment_date,
            bluebox.get_replacement_cost(li.film_id) as amount
        FROM closed_rentals cr
        JOIN lost_inventory li ON li.inventory_id = cr.inventory_id
    ),
    
    created_payments AS (
        INSERT INTO bluebox.payment (customer_id, rental_id, amount, payment_date)
        SELECT customer_id, rental_id, amount, payment_date
        FROM payment_info
        RETURNING payment_id
    )
    
    SELECT 
        (SELECT count(*) FROM closed_rentals),
        (SELECT count(*) FROM created_payments)
    INTO v_lost_count, v_payments_created;
    
    IF p_print_debug THEN
        RAISE NOTICE 'Marked % rentals as lost, created % payments (replacement cost)', 
            v_lost_count, v_payments_created;
    END IF;
    
    COMMIT;
END;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.generate_rentals(timestamp with time zone, timestamp with time zone, boolean, numeric, numeric, double precision, integer, boolean)...';END$$;
CREATE PROCEDURE bluebox.generate_rentals(IN p_start_time timestamp with time zone DEFAULT now(), IN p_end_time timestamp with time zone DEFAULT (now() + '00:05:00'::interval), IN p_close_rentals boolean DEFAULT false, IN p_min_cust_pct numeric DEFAULT 0.8, IN p_max_cust_pct numeric DEFAULT 2.5, IN p_holiday_multiplier double precision DEFAULT 2.5, IN p_store_distance integer DEFAULT 25000, IN p_print_debug boolean DEFAULT false)
LANGUAGE plpgsql
AS $_$
DECLARE
    v_cust_percent float;
    v_target_rentals int;
    v_active_customer_count int;
    v_interval_hours numeric;
    v_sample_pct numeric;
    v_rentals_created int;
BEGIN
    -- Validate inputs
    IF p_start_time >= p_end_time THEN
        RAISE EXCEPTION 'p_end_time must be after p_start_time';
    END IF;
    
    -- Calculate interval in hours
    v_interval_hours := EXTRACT(EPOCH FROM (p_end_time - p_start_time)) / 3600.0;
    
    IF v_interval_hours > 8784 THEN  -- ~366 days
        RAISE EXCEPTION 'Maximum interval is 366 days. Requested: % hours', v_interval_hours;
    END IF;
    
    -- Get active customer count
    SELECT count(*) INTO v_active_customer_count 
    FROM bluebox.customer WHERE activebool = TRUE;
    
    -- Calculate customer percentage
    SELECT random_between(p_min_cust_pct, p_max_cust_pct, 3) INTO v_cust_percent;
    
    -- Check for holidays - increase volume
    IF EXISTS (
        SELECT 1 FROM bluebox.holiday 
        WHERE holiday_date::timestamptz <@ tstzrange(p_start_time, p_end_time)
    ) THEN
        IF p_print_debug THEN
            RAISE NOTICE 'Holiday detected in range';
        END IF;
        SELECT random_between(
            p_min_cust_pct * p_holiday_multiplier, 
            p_max_cust_pct * p_holiday_multiplier, 
            3
        ) INTO v_cust_percent;
    END IF;
    
    -- Calculate target rentals, scaled by interval
    v_target_rentals := GREATEST(1,
        (v_active_customer_count * v_cust_percent / 100 * v_interval_hours / 24)::int
    );
    
    -- Calculate TABLESAMPLE percentage (with buffer for filtering)
    v_sample_pct := GREATEST(0.001, LEAST(100, 
        (v_target_rentals * 1.5 / NULLIF(v_active_customer_count, 0) * 100)::numeric(10,4)
    ));
    
    IF p_print_debug THEN
        RAISE NOTICE 'Time range: % to % (% hours)', p_start_time, p_end_time, round(v_interval_hours::numeric, 2);
        RAISE NOTICE 'Active customers: %, Cust%%: %, Target rentals: %', 
            v_active_customer_count, round(v_cust_percent::numeric, 3), v_target_rentals;
        RAISE NOTICE 'Close rentals: %, Sample%%: %', p_close_rentals, v_sample_pct;
    END IF;

    -- Single unified CTE chain - behavior controlled by p_close_rentals
    WITH outstanding_rentals AS MATERIALIZED (
        SELECT customer_id, inventory_id 
        FROM bluebox.rental
        WHERE rental_period && tstzrange(p_start_time, p_end_time)
           -- For open rentals mode, also exclude customers with any open rental
           OR (NOT p_close_rentals AND upper(rental_period) IS NULL)
    ),
    
    rental_customers AS MATERIALIZED (
        SELECT c.customer_id, c.geog
        FROM bluebox.customer c TABLESAMPLE BERNOULLI(v_sample_pct)
        WHERE c.activebool = TRUE
          AND c.customer_id NOT IN (SELECT customer_id FROM outstanding_rentals)
        LIMIT v_target_rentals
    ),
    
    customer_stores AS MATERIALIZED (
        SELECT 
            c.customer_id,
            stores.rental_store_id,
            stores.return_store_id,  -- Will be same as rental_store_id if only 1 store found or open mode
            row_number() OVER (PARTITION BY stores.rental_store_id ORDER BY random()) as store_rn
        FROM rental_customers c
        CROSS JOIN LATERAL (
            SELECT 
                store_ids[1] as rental_store_id,
                -- For closed rentals: use 2nd store if available; for open: always use rental store
                CASE 
                    WHEN p_close_rentals THEN COALESCE(store_ids[2], store_ids[1])
                    ELSE store_ids[1]
                END as return_store_id
            FROM (
                SELECT array_agg(s.store_id) as store_ids
                FROM (
                    SELECT store_id
                    FROM bluebox.store s
                    WHERE ST_DWithin(s.geog, c.geog, p_store_distance)
                    ORDER BY random()
                    -- For closed: get 2 stores; for open: only need 1
                    LIMIT CASE WHEN p_close_rentals THEN 2 ELSE 1 END
                ) s
            ) sub
        ) stores
    ),
    
    matched_rentals AS MATERIALIZED (
        SELECT 
            cs.customer_id,
            cs.rental_store_id,
            cs.return_store_id,
            inv.inventory_id,
            -- Distribute rental start times across the interval
            p_start_time + (random() * v_interval_hours * 3600) * interval '1 second' as rental_start_time
        FROM customer_stores cs
        CROSS JOIN LATERAL (
            SELECT i.inventory_id
            FROM bluebox.inventory i
            INNER JOIN bluebox.film f USING(film_id)
            WHERE i.store_id = cs.rental_store_id
              AND i.status_id = 1
              AND i.inventory_id NOT IN (SELECT inventory_id FROM outstanding_rentals)
              AND f.release_date <= p_start_time::date
            ORDER BY random()
            LIMIT 1
        ) inv
    ),
    
    created_rentals AS (
        INSERT INTO bluebox.rental (rental_period, inventory_id, customer_id, store_id)
        SELECT 
            CASE 
                WHEN p_close_rentals THEN
                    -- Closed: set end time 10-72 hours after start
                    tstzrange(
                        rental_start_time,
                        rental_start_time + ((random() * 62 + 10) * interval '1 hour')
                    )
                ELSE
                    -- Open: NULL upper bound
                    tstzrange(rental_start_time, NULL)
            END,
            inventory_id,
            customer_id,
            rental_store_id
        FROM matched_rentals
        RETURNING rental_id, inventory_id
    ),
    
    -- Update inventory location only for closed rentals
    inventory_updates AS (
        UPDATE bluebox.inventory i
        SET store_id = mr.return_store_id,
            last_update = now()
        FROM matched_rentals mr
        WHERE i.inventory_id = mr.inventory_id
          AND p_close_rentals  -- Only execute for closed rentals
          AND mr.return_store_id IS DISTINCT FROM mr.rental_store_id  -- Only if actually moving
        RETURNING i.inventory_id
    )
    
    SELECT count(*) INTO v_rentals_created FROM created_rentals;
    
    IF p_print_debug THEN
        RAISE NOTICE 'Created % rentals (closed: %)', v_rentals_created, p_close_rentals;
    END IF;
    
    COMMIT;
    
    -- Generate payments for closed rentals
    IF p_close_rentals AND v_rentals_created > 0 THEN
        CALL bluebox.insert_payments(p_start_time::date);
        IF p_print_debug THEN
            RAISE NOTICE 'Payments generated for %', p_start_time::date;
        END IF;
    END IF;
END;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.complete_rentals(interval, numeric, numeric, integer, interval, interval, boolean)...';END$$;
CREATE PROCEDURE bluebox.complete_rentals(IN p_min_rental_age interval DEFAULT '16:00:00'::interval, IN p_completion_pct numeric DEFAULT 15.0, IN p_skip_pct numeric DEFAULT 0.1, IN p_store_distance integer DEFAULT 25000, IN p_min_duration interval DEFAULT '16:00:00'::interval, IN p_max_duration interval DEFAULT '96:00:00'::interval, IN p_print_debug boolean DEFAULT false)
LANGUAGE plpgsql
AS $_$
DECLARE
    v_eligible_count int;
    v_skip_count int;
    v_target_count int;
    v_completed_count int;
    v_payments_created int;
BEGIN
    -- Count eligible rentals (open and old enough)
    SELECT count(*) INTO v_eligible_count
    FROM bluebox.rental
    WHERE upper(rental_period) IS NULL
      AND lower(rental_period) < now() - p_min_rental_age;
    
    IF v_eligible_count = 0 THEN
        IF p_print_debug THEN
            RAISE NOTICE 'No eligible rentals to complete';
        END IF;
        RETURN;
    END IF;
    
    -- Calculate how many to skip (future lost items) and how many to complete
    v_skip_count := GREATEST(0, (v_eligible_count * p_skip_pct / 100)::int);
    v_target_count := GREATEST(1, (v_eligible_count * p_completion_pct / 100)::int);
    
    IF p_print_debug THEN
        RAISE NOTICE 'Eligible rentals: %, Skipping: % (%.2f%%), Target to complete: % (%.1f%%)', 
            v_eligible_count, v_skip_count, p_skip_pct, v_target_count, p_completion_pct;
    END IF;

    -- Complete rentals and move inventory in a single CTE chain
    WITH eligible_rentals AS MATERIALIZED (
        SELECT 
            r.rental_id,
            r.customer_id,
            r.inventory_id,
            r.store_id as rental_store_id,
            r.rental_period,
            lower(r.rental_period) as rental_start,
            row_number() OVER (ORDER BY random()) as rn
        FROM bluebox.rental r
        WHERE upper(r.rental_period) IS NULL
          AND lower(r.rental_period) < now() - p_min_rental_age
    ),
    
    sampled_rentals AS MATERIALIZED (
        SELECT rental_id, customer_id, inventory_id, rental_store_id, rental_period, rental_start
        FROM eligible_rentals
        WHERE rn > v_skip_count
          AND rn <= v_skip_count + v_target_count
    ),
    
    rentals_with_return_store AS MATERIALIZED (
        SELECT 
            sr.*,
            COALESCE(return_store.store_id, sr.rental_store_id) as return_store_id,
            GREATEST(
                now(),
                sr.rental_start + p_min_duration + 
                    (random() * EXTRACT(EPOCH FROM (p_max_duration - p_min_duration))) * interval '1 second'
            ) as return_time
        FROM sampled_rentals sr
        LEFT JOIN LATERAL (
            SELECT s.store_id
            FROM bluebox.store s
            JOIN bluebox.customer c ON c.customer_id = sr.customer_id
            WHERE ST_DWithin(s.geog, c.geog, p_store_distance)
            ORDER BY random()
            LIMIT 1
        ) return_store ON true
    ),
    
    completed_rentals AS (
        UPDATE bluebox.rental r
        SET rental_period = tstzrange(lower(r.rental_period), rwr.return_time)
        FROM rentals_with_return_store rwr
        WHERE r.rental_id = rwr.rental_id
        RETURNING r.rental_id, r.customer_id, r.inventory_id, 
                  rwr.return_store_id, rwr.return_time
    ),
    
    inventory_moves AS (
        UPDATE bluebox.inventory i
        SET store_id = cr.return_store_id,
            last_update = now()
        FROM completed_rentals cr
        WHERE i.inventory_id = cr.inventory_id
          AND i.store_id != cr.return_store_id
        RETURNING i.inventory_id
    ),
    
    payment_info AS (
        SELECT 
            cr.rental_id,
            cr.customer_id,
            cr.return_time as payment_date,
            GREATEST(1, 
                CEILING(EXTRACT(EPOCH FROM (cr.return_time - lower(r.rental_period))) / 86400)
            ) as rental_days,
            i.film_id
        FROM completed_rentals cr
        JOIN bluebox.rental r ON r.rental_id = cr.rental_id
        JOIN bluebox.inventory i ON i.inventory_id = cr.inventory_id
    ),
    
    created_payments AS (
        INSERT INTO bluebox.payment (customer_id, rental_id, amount, payment_date)
        SELECT 
            customer_id,
            rental_id,
            rental_days * bluebox.get_daily_rental_rate(film_id) AS amount,
            payment_date
        FROM payment_info
        RETURNING payment_id
    )
    
    SELECT 
        (SELECT count(*) FROM completed_rentals),
        (SELECT count(*) FROM created_payments)
    INTO v_completed_count, v_payments_created;
    
    IF p_print_debug THEN
        RAISE NOTICE 'Completed % rentals, created % payments', v_completed_count, v_payments_created;
    END IF;
    
    COMMIT;
END;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Altering bluebox.insert_payments(date)...';END$$;
CREATE OR REPLACE PROCEDURE bluebox.insert_payments(IN rd date)
LANGUAGE plpgsql
AS $_$
BEGIN 
    WITH payment_info AS (
        SELECT 
            r.rental_id, 
            rental_period, 
            GREATEST(CEILING(EXTRACT(epoch FROM (upper(rental_period)-lower(rental_period)))/3600/24), 1) AS rental_days,
            inventory_id, 
            r.customer_id, 
            upper(rental_period) AS payment_date,
            i.film_id
        FROM bluebox.rental r
        INNER JOIN bluebox.inventory i USING(inventory_id)
        LEFT JOIN bluebox.payment p ON r.rental_id = p.rental_id
        WHERE lower(rental_period) >= rd 
          AND lower(rental_period) <= rd + '5 days'::INTERVAL
          AND p.rental_id IS NULL 
    )
    INSERT INTO bluebox.payment (customer_id, rental_id, amount, payment_date)
    SELECT 
        customer_id, 
        rental_id, 
        rental_days * bluebox.get_daily_rental_rate(film_id) AS amount, 
        payment_date
    FROM payment_info;
END;
$_$;

SET check_function_bodies = true;
