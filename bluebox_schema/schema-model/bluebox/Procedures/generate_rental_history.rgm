procedure "bluebox"."generate_rental_history(date, date, numeric, numeric, numeric, integer, boolean)" {
  text = """

DECLARE
    v_current_date date;
    v_day_start timestamptz;
    v_day_end timestamptz;
    v_cust_percent numeric;
    v_is_holiday boolean;
    v_target_rentals int;
    v_active_customer_count int;
    v_sample_pct numeric;
    v_rentals_created int;
    v_total_rentals int := 0;
    v_days_processed int := 0;
    v_start_time timestamptz;
BEGIN
    -- Validate inputs
    IF p_start_date > p_end_date THEN
        RAISE EXCEPTION 'p_end_date must be on or after p_start_date';
    END IF;
    
    IF p_end_date - p_start_date > 366 THEN
        RAISE EXCEPTION 'Maximum range is 366 days. Requested: % days', p_end_date - p_start_date;
    END IF;
    
    v_start_time := clock_timestamp();
    
    IF p_print_debug THEN
        RAISE NOTICE '=== Starting rental history generation ===';
        RAISE NOTICE 'Date range: % to % (% days)', p_start_date, p_end_date, p_end_date - p_start_date + 1;
    END IF;
    
    -- Get active customer count (constant for the run)
    SELECT count(*) INTO v_active_customer_count 
    FROM bluebox.customer WHERE activebool = TRUE;
    
    -- Loop through each day
    v_current_date := p_start_date;
    
    WHILE v_current_date <= p_end_date LOOP
        v_day_start := v_current_date::timestamptz;
        v_day_end := (v_current_date + 1)::timestamptz;
        
        -- Check if this day is a holiday
        v_is_holiday := EXISTS (
            SELECT 1 FROM bluebox.holiday 
            WHERE holiday_date = v_current_date
        );
        
        -- Calculate customer percentage for this day
        IF v_is_holiday THEN
            v_cust_percent := bluebox.random_between(
                p_min_cust_pct * p_holiday_multiplier, 
                p_max_cust_pct * p_holiday_multiplier, 
                3
            );
        ELSE
            v_cust_percent := bluebox.random_between(p_min_cust_pct, p_max_cust_pct, 3);
        END IF;
        
        -- Calculate target rentals for this day
        v_target_rentals := GREATEST(1, (v_active_customer_count * v_cust_percent / 100)::int);
        
        -- Calculate TABLESAMPLE percentage
        v_sample_pct := GREATEST(0.001, LEAST(100, 
            (v_target_rentals * 1.5 / NULLIF(v_active_customer_count, 0) * 100)::numeric(10,4)
        ));
        
        -- Generate rentals for this day
        WITH outstanding_rentals AS MATERIALIZED (
            -- For historical generation, only exclude inventory currently rented on this day
            -- Customers CAN rent again if their previous rental from an earlier day is returned
            SELECT inventory_id 
            FROM bluebox.rental
            WHERE rental_period && tstzrange(v_day_start, v_day_end)
        ),
        
        -- Get customers who don't have an active rental on this specific day
        rental_customers AS MATERIALIZED (
            SELECT c.customer_id, c.geog
            FROM bluebox.customer c TABLESAMPLE BERNOULLI(v_sample_pct)
            WHERE c.activebool = TRUE
              AND NOT EXISTS (
                  SELECT 1 FROM bluebox.rental r
                  WHERE r.customer_id = c.customer_id
                    AND r.rental_period && tstzrange(v_day_start, v_day_end)
              )
            LIMIT v_target_rentals
        ),
        
        customer_stores AS MATERIALIZED (
            SELECT 
                c.customer_id,
                stores.rental_store_id,
                stores.return_store_id,
                row_number() OVER (PARTITION BY stores.rental_store_id ORDER BY random()) as store_rn
            FROM rental_customers c
            CROSS JOIN LATERAL (
                SELECT 
                    store_ids[1] as rental_store_id,
                    COALESCE(store_ids[2], store_ids[1]) as return_store_id
                FROM (
                    SELECT array_agg(s.store_id) as store_ids
                    FROM (
                        SELECT store_id
                        FROM bluebox.store s
                        WHERE ST_DWithin(s.geog, c.geog, p_store_distance)
                        ORDER BY random()
                        LIMIT 2
                    ) s
                ) sub
            ) stores
        ),
        
        matched_rentals AS MATERIALIZED (
            SELECT 
                cs.customer_id,
                cs.rental_store_id,
                cs.return_store_id,
                inv.inventory_id,
                -- Random start time within the day
                v_day_start + (random() * 86400) * interval '1 second' as rental_start_time
            FROM customer_stores cs
            CROSS JOIN LATERAL (
                SELECT i.inventory_id
                FROM bluebox.inventory i
                INNER JOIN bluebox.film f USING(film_id)
                WHERE i.store_id = cs.rental_store_id
                  AND i.status_id = 1
                  AND i.inventory_id NOT IN (SELECT inventory_id FROM outstanding_rentals)
                  AND f.release_date <= v_current_date
                ORDER BY random()
                LIMIT 1
            ) inv
        ),
        
        created_rentals AS (
            INSERT INTO bluebox.rental (rental_period, inventory_id, customer_id, store_id)
            SELECT 
                -- Closed rental: 10-72 hours duration
                tstzrange(
                    rental_start_time,
                    rental_start_time + ((random() * 62 + 10) * interval '1 hour')
                ),
                inventory_id,
                customer_id,
                rental_store_id
            FROM matched_rentals
            RETURNING rental_id, inventory_id
        ),
        
        inventory_updates AS (
            UPDATE bluebox.inventory i
            SET store_id = mr.return_store_id,
                last_update = now()
            FROM matched_rentals mr
            WHERE i.inventory_id = mr.inventory_id
              AND mr.return_store_id IS DISTINCT FROM mr.rental_store_id
            RETURNING i.inventory_id
        )
        
        SELECT count(*) INTO v_rentals_created FROM created_rentals;
        
        -- Generate payments for this day's rentals
        IF v_rentals_created > 0 THEN
            CALL bluebox.insert_payments(v_current_date);
        END IF;
        
        v_total_rentals := v_total_rentals + v_rentals_created;
        v_days_processed := v_days_processed + 1;
        
        IF p_print_debug THEN
            RAISE NOTICE '% | % rentals | cust%%: % | holiday: %', 
                v_current_date, 
                v_rentals_created,
                round(v_cust_percent, 2),
                v_is_holiday;
        END IF;
        
        COMMIT;
        
        v_current_date := v_current_date + 1;
    END LOOP;
    
    IF p_print_debug THEN
        RAISE NOTICE '=== Rental history generation complete ===';
        RAISE NOTICE 'Days processed: %, Total rentals: %, Time: % seconds', 
            v_days_processed,
            v_total_rentals,
            round(EXTRACT(EPOCH FROM clock_timestamp() - v_start_time)::numeric, 2);
    END IF;
END;
"""
  arguments = <
    {
      name = p_start_date
      type = date
      mode = IN
    }

    {
      name = p_end_date
      type = date
      mode = IN
      default = """-
(CURRENT_DATE - 1)
"""
    }

    {
      name = p_min_cust_pct
      type = numeric
      mode = IN
      default = 0.8
    }

    {
      name = p_max_cust_pct
      type = numeric
      mode = IN
      default = 2.5
    }

    {
      name = p_holiday_multiplier
      type = numeric
      mode = IN
      default = 2.5
    }

    {
      name = p_store_distance
      type = integer
      mode = IN
      default = 25000
    }

    {
      name = p_print_debug
      type = boolean
      mode = IN
      default = false
    }

  >
  language = plpgsql
}

