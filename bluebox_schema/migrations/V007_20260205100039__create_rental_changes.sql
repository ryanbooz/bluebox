-- Script generated by Redgate Compare v1.48.1.2539
SET check_function_bodies = false;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping public.random_between(numeric, numeric, integer)...';END$$;
DROP FUNCTION public.random_between(numeric, numeric, integer);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping bluebox.generate_rentals(timestamp with time zone, timestamp with time zone, boolean, numeric, numeric, double precision, integer, boolean)...';END$$;
DROP PROCEDURE bluebox.generate_rentals(timestamp with time zone, timestamp with time zone, boolean, numeric, numeric, double precision, integer, boolean);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.random_between(numeric, numeric, integer)...';END$$;
CREATE FUNCTION bluebox.random_between(IN min_val numeric, IN max_val numeric, IN round_to integer DEFAULT 0)
RETURNS numeric
LANGUAGE plpgsql
AS $_$
DECLARE
    value NUMERIC = random() * (max_val - min_val) + min_val;
BEGIN
   IF round_to = 0 THEN 
       RETURN floor(value);
   ELSE 
       RETURN round(value, round_to);
   END IF;
END
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.generate_rental_history(date, date, numeric, numeric, numeric, integer, boolean)...';END$$;
CREATE PROCEDURE bluebox.generate_rental_history(IN p_start_date date, IN p_end_date date DEFAULT (CURRENT_DATE - 1), IN p_min_cust_pct numeric DEFAULT 0.8, IN p_max_cust_pct numeric DEFAULT 2.5, IN p_holiday_multiplier numeric DEFAULT 2.5, IN p_store_distance integer DEFAULT 25000, IN p_print_debug boolean DEFAULT false)
LANGUAGE plpgsql
AS $_$
DECLARE
    v_current_date date;
    v_day_start timestamptz;
    v_day_end timestamptz;
    v_cust_percent numeric;
    v_is_holiday boolean;
    v_target_rentals int;
    v_active_customer_count int;
    v_sample_pct numeric;
    v_rentals_created int;
    v_total_rentals int := 0;
    v_days_processed int := 0;
    v_start_time timestamptz;
BEGIN
    -- Validate inputs
    IF p_start_date > p_end_date THEN
        RAISE EXCEPTION 'p_end_date must be on or after p_start_date';
    END IF;
    
    IF p_end_date - p_start_date > 366 THEN
        RAISE EXCEPTION 'Maximum range is 366 days. Requested: % days', p_end_date - p_start_date;
    END IF;
    
    v_start_time := clock_timestamp();
    
    IF p_print_debug THEN
        RAISE NOTICE '=== Starting rental history generation ===';
        RAISE NOTICE 'Date range: % to % (% days)', p_start_date, p_end_date, p_end_date - p_start_date + 1;
    END IF;
    
    -- Get active customer count (constant for the run)
    SELECT count(*) INTO v_active_customer_count 
    FROM bluebox.customer WHERE activebool = TRUE;
    
    -- Loop through each day
    v_current_date := p_start_date;
    
    WHILE v_current_date <= p_end_date LOOP
        v_day_start := v_current_date::timestamptz;
        v_day_end := (v_current_date + 1)::timestamptz;
        
        -- Check if this day is a holiday
        v_is_holiday := EXISTS (
            SELECT 1 FROM bluebox.holiday 
            WHERE holiday_date = v_current_date
        );
        
        -- Calculate customer percentage for this day
        IF v_is_holiday THEN
            v_cust_percent := bluebox.random_between(
                p_min_cust_pct * p_holiday_multiplier, 
                p_max_cust_pct * p_holiday_multiplier, 
                3
            );
        ELSE
            v_cust_percent := bluebox.random_between(p_min_cust_pct, p_max_cust_pct, 3);
        END IF;
        
        -- Calculate target rentals for this day
        v_target_rentals := GREATEST(1, (v_active_customer_count * v_cust_percent / 100)::int);
        
        -- Calculate TABLESAMPLE percentage
        v_sample_pct := GREATEST(0.001, LEAST(100, 
            (v_target_rentals * 1.5 / NULLIF(v_active_customer_count, 0) * 100)::numeric(10,4)
        ));
        
        -- Generate rentals for this day
        WITH outstanding_rentals AS MATERIALIZED (
            -- For historical generation, only exclude inventory currently rented on this day
            -- Customers CAN rent again if their previous rental from an earlier day is returned
            SELECT inventory_id 
            FROM bluebox.rental
            WHERE rental_period && tstzrange(v_day_start, v_day_end)
        ),
        
        -- Get customers who don't have an active rental on this specific day
        rental_customers AS MATERIALIZED (
            SELECT c.customer_id, c.geog
            FROM bluebox.customer c TABLESAMPLE BERNOULLI(v_sample_pct)
            WHERE c.activebool = TRUE
              AND NOT EXISTS (
                  SELECT 1 FROM bluebox.rental r
                  WHERE r.customer_id = c.customer_id
                    AND r.rental_period && tstzrange(v_day_start, v_day_end)
              )
            LIMIT v_target_rentals
        ),
        
        customer_stores AS MATERIALIZED (
            SELECT 
                c.customer_id,
                stores.rental_store_id,
                stores.return_store_id,
                row_number() OVER (PARTITION BY stores.rental_store_id ORDER BY random()) as store_rn
            FROM rental_customers c
            CROSS JOIN LATERAL (
                SELECT 
                    store_ids[1] as rental_store_id,
                    COALESCE(store_ids[2], store_ids[1]) as return_store_id
                FROM (
                    SELECT array_agg(s.store_id) as store_ids
                    FROM (
                        SELECT store_id
                        FROM bluebox.store s
                        WHERE ST_DWithin(s.geog, c.geog, p_store_distance)
                        ORDER BY random()
                        LIMIT 2
                    ) s
                ) sub
            ) stores
        ),
        
        matched_rentals AS MATERIALIZED (
            SELECT 
                cs.customer_id,
                cs.rental_store_id,
                cs.return_store_id,
                inv.inventory_id,
                -- Random start time within the day
                v_day_start + (random() * 86400) * interval '1 second' as rental_start_time
            FROM customer_stores cs
            CROSS JOIN LATERAL (
                SELECT i.inventory_id
                FROM bluebox.inventory i
                INNER JOIN bluebox.film f USING(film_id)
                WHERE i.store_id = cs.rental_store_id
                  AND i.status_id = 1
                  AND i.inventory_id NOT IN (SELECT inventory_id FROM outstanding_rentals)
                  AND f.release_date <= v_current_date
                ORDER BY random()
                LIMIT 1
            ) inv
        ),
        
        created_rentals AS (
            INSERT INTO bluebox.rental (rental_period, inventory_id, customer_id, store_id)
            SELECT 
                -- Closed rental: 10-72 hours duration
                tstzrange(
                    rental_start_time,
                    rental_start_time + ((random() * 62 + 10) * interval '1 hour')
                ),
                inventory_id,
                customer_id,
                rental_store_id
            FROM matched_rentals
            RETURNING rental_id, inventory_id
        ),
        
        inventory_updates AS (
            UPDATE bluebox.inventory i
            SET store_id = mr.return_store_id,
                last_update = now()
            FROM matched_rentals mr
            WHERE i.inventory_id = mr.inventory_id
              AND mr.return_store_id IS DISTINCT FROM mr.rental_store_id
            RETURNING i.inventory_id
        )
        
        SELECT count(*) INTO v_rentals_created FROM created_rentals;
        
        -- Generate payments for this day's rentals
        IF v_rentals_created > 0 THEN
            CALL bluebox.insert_payments(v_current_date);
        END IF;
        
        v_total_rentals := v_total_rentals + v_rentals_created;
        v_days_processed := v_days_processed + 1;
        
        IF p_print_debug THEN
            RAISE NOTICE '% | % rentals | cust%%: % | holiday: %', 
                v_current_date, 
                v_rentals_created,
                round(v_cust_percent, 2),
                v_is_holiday;
        END IF;
        
        COMMIT;
        
        v_current_date := v_current_date + 1;
    END LOOP;
    
    IF p_print_debug THEN
        RAISE NOTICE '=== Rental history generation complete ===';
        RAISE NOTICE 'Days processed: %, Total rentals: %, Time: % seconds', 
            v_days_processed,
            v_total_rentals,
            round(EXTRACT(EPOCH FROM clock_timestamp() - v_start_time)::numeric, 2);
    END IF;
END;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.generate_rentals(timestamp with time zone, timestamp with time zone, boolean, numeric, numeric, numeric, integer, boolean)...';END$$;
CREATE PROCEDURE bluebox.generate_rentals(IN p_start_time timestamp with time zone DEFAULT now(), IN p_end_time timestamp with time zone DEFAULT (now() + '00:05:00'::interval), IN p_close_rentals boolean DEFAULT false, IN p_min_cust_pct numeric DEFAULT 0.8, IN p_max_cust_pct numeric DEFAULT 2.5, IN p_holiday_multiplier numeric DEFAULT 2.5, IN p_store_distance integer DEFAULT 25000, IN p_print_debug boolean DEFAULT false)
LANGUAGE plpgsql
AS $_$
DECLARE
    v_cust_percent float;
    v_target_rentals int;
    v_active_customer_count int;
    v_interval_hours numeric;
    v_sample_pct numeric;
    v_rentals_created int;
BEGIN
    -- Validate inputs
    IF p_start_time >= p_end_time THEN
        RAISE EXCEPTION 'p_end_time must be after p_start_time';
    END IF;
    
    -- Calculate interval in hours
    v_interval_hours := EXTRACT(EPOCH FROM (p_end_time - p_start_time)) / 3600.0;
    
    IF v_interval_hours > 24 THEN
        RAISE EXCEPTION 'Maximum interval is 24 hours. For multi-day generation, use generate_rental_history() instead. Requested: % hours', v_interval_hours;
    END IF;
    
    -- Get active customer count
    SELECT count(*) INTO v_active_customer_count 
    FROM bluebox.customer WHERE activebool = TRUE;
    
    -- Calculate customer percentage (QUALIFIED)
    SELECT bluebox.random_between(p_min_cust_pct, p_max_cust_pct, 3) INTO v_cust_percent;
    
    -- Check for holidays - increase volume
    IF EXISTS (
        SELECT 1 FROM bluebox.holiday 
        WHERE holiday_date::timestamptz <@ tstzrange(p_start_time, p_end_time)
    ) THEN
        IF p_print_debug THEN
            RAISE NOTICE 'Holiday detected in range';
        END IF;
        SELECT bluebox.random_between(
            p_min_cust_pct * p_holiday_multiplier, 
            p_max_cust_pct * p_holiday_multiplier, 
            3
        ) INTO v_cust_percent;
    END IF;
    
    -- Calculate target rentals, scaled by interval
    v_target_rentals := GREATEST(1,
        (v_active_customer_count * v_cust_percent / 100 * v_interval_hours / 24)::int
    );
    
    -- Calculate TABLESAMPLE percentage (with buffer for filtering)
    v_sample_pct := GREATEST(0.001, LEAST(100, 
        (v_target_rentals * 1.5 / NULLIF(v_active_customer_count, 0) * 100)::numeric(10,4)
    ));
    
    IF p_print_debug THEN
        RAISE NOTICE 'Time range: % to % (% hours)', p_start_time, p_end_time, round(v_interval_hours::numeric, 2);
        RAISE NOTICE 'Active customers: %, Cust%%: %, Target rentals: %', 
            v_active_customer_count, round(v_cust_percent::numeric, 3), v_target_rentals;
        RAISE NOTICE 'Close rentals: %, Sample%%: %', p_close_rentals, v_sample_pct;
    END IF;

    -- Single unified CTE chain - behavior controlled by p_close_rentals
    WITH outstanding_rentals AS MATERIALIZED (
        SELECT customer_id, inventory_id 
        FROM bluebox.rental
        WHERE rental_period && tstzrange(p_start_time, p_end_time)
           -- For open rentals mode, also exclude customers with any open rental
           OR (NOT p_close_rentals AND upper(rental_period) IS NULL)
    ),
    
    rental_customers AS MATERIALIZED (
        SELECT c.customer_id, c.geog
        FROM bluebox.customer c TABLESAMPLE BERNOULLI(v_sample_pct)
        WHERE c.activebool = TRUE
          AND c.customer_id NOT IN (SELECT customer_id FROM outstanding_rentals)
        LIMIT v_target_rentals
    ),
    
    customer_stores AS MATERIALIZED (
        SELECT 
            c.customer_id,
            stores.rental_store_id,
            stores.return_store_id,
            row_number() OVER (PARTITION BY stores.rental_store_id ORDER BY random()) as store_rn
        FROM rental_customers c
        CROSS JOIN LATERAL (
            SELECT 
                store_ids[1] as rental_store_id,
                CASE 
                    WHEN p_close_rentals THEN COALESCE(store_ids[2], store_ids[1])
                    ELSE store_ids[1]
                END as return_store_id
            FROM (
                SELECT array_agg(s.store_id) as store_ids
                FROM (
                    SELECT store_id
                    FROM bluebox.store s
                    WHERE ST_DWithin(s.geog, c.geog, p_store_distance)
                    ORDER BY random()
                    LIMIT CASE WHEN p_close_rentals THEN 2 ELSE 1 END
                ) s
            ) sub
        ) stores
    ),
    
    matched_rentals AS MATERIALIZED (
        SELECT 
            cs.customer_id,
            cs.rental_store_id,
            cs.return_store_id,
            inv.inventory_id,
            p_start_time + (random() * v_interval_hours * 3600) * interval '1 second' as rental_start_time
        FROM customer_stores cs
        CROSS JOIN LATERAL (
            SELECT i.inventory_id
            FROM bluebox.inventory i
            INNER JOIN bluebox.film f USING(film_id)
            WHERE i.store_id = cs.rental_store_id
              AND i.status_id = 1
              AND i.inventory_id NOT IN (SELECT inventory_id FROM outstanding_rentals)
              AND f.release_date <= p_start_time::date
            ORDER BY random()
            LIMIT 1
        ) inv
    ),
    
    created_rentals AS (
        INSERT INTO bluebox.rental (rental_period, inventory_id, customer_id, store_id)
        SELECT 
            CASE 
                WHEN p_close_rentals THEN
                    tstzrange(
                        rental_start_time,
                        rental_start_time + ((random() * 62 + 10) * interval '1 hour')
                    )
                ELSE
                    tstzrange(rental_start_time, NULL)
            END,
            inventory_id,
            customer_id,
            rental_store_id
        FROM matched_rentals
        RETURNING rental_id, inventory_id
    ),
    
    inventory_updates AS (
        UPDATE bluebox.inventory i
        SET store_id = mr.return_store_id,
            last_update = now()
        FROM matched_rentals mr
        WHERE i.inventory_id = mr.inventory_id
          AND p_close_rentals
          AND mr.return_store_id IS DISTINCT FROM mr.rental_store_id
        RETURNING i.inventory_id
    )
    
    SELECT count(*) INTO v_rentals_created FROM created_rentals;
    
    IF p_print_debug THEN
        RAISE NOTICE 'Created % rentals (closed: %)', v_rentals_created, p_close_rentals;
    END IF;
    
    COMMIT;
    
    -- Generate payments for closed rentals
    IF p_close_rentals AND v_rentals_created > 0 THEN
        CALL bluebox.insert_payments(p_start_time::date);
        IF p_print_debug THEN
            RAISE NOTICE 'Payments generated for %', p_start_time::date;
        END IF;
    END IF;
END;
$_$;

SET check_function_bodies = true;
