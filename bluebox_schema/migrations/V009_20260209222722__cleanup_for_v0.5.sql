-- Script generated by Redgate Compare v1.48.1.2539
SET check_function_bodies = false;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping public.last_updated()...';END$$;
DROP FUNCTION public.last_updated();


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping public.last_day(timestamp with time zone)...';END$$;
DROP FUNCTION public.last_day(timestamp with time zone);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping public.get_inventory()...';END$$;
DROP FUNCTION public.get_inventory();


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping bluebox.inventory_in_stock(integer)...';END$$;
DROP FUNCTION bluebox.inventory_in_stock(integer);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping bluebox.inventory_held_by_customer(integer)...';END$$;
DROP FUNCTION bluebox.inventory_held_by_customer(integer);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping bluebox.film_not_in_stock(integer, integer)...';END$$;
DROP FUNCTION bluebox.film_not_in_stock(integer, integer);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping bluebox.film_in_stock(integer, integer)...';END$$;
DROP FUNCTION bluebox.film_in_stock(integer, integer);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping bluebox.rental_rental_period_upper_null...';END$$;
DROP INDEX bluebox.rental_rental_period_upper_null;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.get_inventory_status_summary()...';END$$;
CREATE FUNCTION bluebox.get_inventory_status_summary()
RETURNS TABLE(status_code text, description text, inventory_count bigint, pct_of_total numeric)
LANGUAGE sql
AS $_$
    SELECT 
        s.status_code,
        s.description,
        COUNT(i.inventory_id),
        ROUND(100.0 * COUNT(i.inventory_id) / SUM(COUNT(i.inventory_id)) OVER (), 2)
    FROM bluebox.inventory_status s
    LEFT JOIN bluebox.inventory i ON s.status_id = i.status_id
    GROUP BY s.status_id, s.status_code, s.description, s.display_order
    ORDER BY s.display_order;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.get_inventory_balance_report()...';END$$;
CREATE FUNCTION bluebox.get_inventory_balance_report()
RETURNS TABLE(store_id bigint, nearby_customers bigint, current_inventory bigint, target_inventory integer, variance integer, variance_pct numeric)
LANGUAGE sql
AS $_$
    WITH store_metrics AS (
        SELECT 
            s.store_id,
            count(DISTINCT c.customer_id) as nearby_customers
        FROM bluebox.store s
        LEFT JOIN bluebox.customer c ON ST_DWithin(s.geog, c.geog, 25000)
        GROUP BY s.store_id
    ),
    totals AS (
        SELECT 
            (SELECT count(*) FROM bluebox.inventory WHERE status_id = 1) as total_inventory,
            (SELECT count(*) FROM bluebox.store) as store_count,
            sum(nearby_customers) as total_customers
        FROM store_metrics
    ),
    dynamic_params AS (
        SELECT 
            (total_inventory / store_count * 0.4)::int as floor_inventory,
            total_inventory - (total_inventory / store_count * 0.4)::int * store_count as remainder,
            total_customers
        FROM totals
    ),
    store_inventory AS (
        SELECT store_id, count(*) as inv_count
        FROM bluebox.inventory
        WHERE status_id = 1
        GROUP BY store_id
    )
    SELECT 
        sm.store_id,
        sm.nearby_customers,
        COALESCE(si.inv_count, 0) as current_inventory,
        dp.floor_inventory + (sm.nearby_customers::float / dp.total_customers * dp.remainder)::int as target_inventory,
        COALESCE(si.inv_count, 0) - (dp.floor_inventory + (sm.nearby_customers::float / dp.total_customers * dp.remainder)::int) as variance,
        ROUND(100.0 * (COALESCE(si.inv_count, 0) - (dp.floor_inventory + (sm.nearby_customers::float / dp.total_customers * dp.remainder)::int)) 
            / (dp.floor_inventory + (sm.nearby_customers::float / dp.total_customers * dp.remainder)::int), 1) as variance_pct
    FROM store_metrics sm
    CROSS JOIN dynamic_params dp
    LEFT JOIN store_inventory si ON sm.store_id = si.store_id
    ORDER BY variance DESC;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.get_overdue_rentals(integer)...';END$$;
CREATE FUNCTION bluebox.get_overdue_rentals(IN overdue_days integer DEFAULT 7)
RETURNS TABLE(rental_id bigint, customer_id bigint, customer_name text, film_title text, rental_start timestamp with time zone, days_overdue integer, replacement_cost numeric)
LANGUAGE sql
AS $_$
    SELECT 
        r.rental_id,
        c.customer_id,
        c.full_name,
        f.title,
        lower(r.rental_period),
        EXTRACT(day FROM now() - lower(r.rental_period))::INTEGER,
        f.replacement_cost
    FROM bluebox.rental r
    JOIN bluebox.customer c ON r.customer_id = c.customer_id
    JOIN bluebox.inventory i ON r.inventory_id = i.inventory_id
    JOIN bluebox.film f ON i.film_id = f.film_id
    WHERE upper(r.rental_period) IS NULL
      AND lower(r.rental_period) < now() - (overdue_days || ' days')::INTERVAL
      AND i.status_id = 1  -- only in_circulation items
    ORDER BY lower(r.rental_period);
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.last_day(timestamp with time zone)...';END$$;
CREATE FUNCTION bluebox.last_day(IN timestamp with time zone)
RETURNS date
LANGUAGE sql
IMMUTABLE
AS $_$
  SELECT CASE
    WHEN EXTRACT(MONTH FROM $1) = 12 THEN
      (((EXTRACT(YEAR FROM $1) + 1) operator(pg_catalog.||) '-01-01')::date - INTERVAL '1 day')::date
    ELSE
      ((EXTRACT(YEAR FROM $1) operator(pg_catalog.||) '-' operator(pg_catalog.||) (EXTRACT(MONTH FROM $1) + 1) operator(pg_catalog.||) '-01')::date - INTERVAL '1 day')::date
    END
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.get_film_availability(integer)...';END$$;
CREATE FUNCTION bluebox.get_film_availability(IN min_stores integer DEFAULT 0)
RETURNS TABLE(film_id bigint, title text, release_date date, popularity real, stores_with_film bigint, total_copies bigint, copies_available bigint)
LANGUAGE sql
AS $_$
    WITH inventory_stats AS (
        SELECT 
            i.film_id,
            count(DISTINCT i.store_id) as stores_with_film,
            count(*) as total_copies,
            count(*) FILTER (WHERE i.status_id = 1 
                AND NOT EXISTS (
                    SELECT 1 FROM bluebox.rental r 
                    WHERE r.inventory_id = i.inventory_id 
                    AND upper(r.rental_period) IS NULL
                )
            ) as copies_available
        FROM bluebox.inventory i
        GROUP BY i.film_id
    )
    SELECT 
        f.film_id,
        f.title,
        f.release_date,
        f.popularity,
        COALESCE(inv.stores_with_film, 0),
        COALESCE(inv.total_copies, 0),
        COALESCE(inv.copies_available, 0)
    FROM bluebox.film f
    LEFT JOIN inventory_stats inv ON f.film_id = inv.film_id
    WHERE COALESCE(inv.stores_with_film, 0) >= min_stores
    ORDER BY f.popularity DESC;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.last_updated()...';END$$;
CREATE FUNCTION bluebox.last_updated()
RETURNS trigger
LANGUAGE plpgsql
AS $_$
BEGIN
    NEW.last_update = CURRENT_TIMESTAMP;
    RETURN NEW;
END $_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.get_customer_status_summary()...';END$$;
CREATE FUNCTION bluebox.get_customer_status_summary()
RETURNS TABLE(status text, customer_count bigint, pct_of_total numeric, avg_lifetime_rentals numeric, avg_lifetime_value numeric)
LANGUAGE sql
AS $_$
    WITH customer_stats AS (
        SELECT 
            c.customer_id,
            c.activebool,
            COUNT(r.rental_id) as rental_count,
            COALESCE(SUM(p.amount), 0) as total_spent,
            MAX(lower(r.rental_period)) as last_rental
        FROM bluebox.customer c
        LEFT JOIN bluebox.rental r ON c.customer_id = r.customer_id
        LEFT JOIN bluebox.payment p ON r.rental_id = p.rental_id
        GROUP BY c.customer_id, c.activebool
    )
    SELECT 
        CASE 
            WHEN NOT activebool THEN 'Inactive'
            WHEN last_rental > now() - interval '30 days' THEN 'Active (30d)'
            WHEN last_rental > now() - interval '90 days' THEN 'Recent (30-90d)'
            WHEN last_rental > now() - interval '180 days' THEN 'Dormant (90-180d)'
            ELSE 'At Risk (>180d)'
        END as status,
        COUNT(*),
        ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2),
        ROUND(AVG(rental_count), 1),
        ROUND(AVG(total_spent), 2)
    FROM customer_stats
    GROUP BY 1
    ORDER BY 2 DESC;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.rebalance_inventory(integer, boolean)...';END$$;
CREATE PROCEDURE bluebox.rebalance_inventory(IN max_moves_per_run integer DEFAULT 10000, IN print_debug boolean DEFAULT false)
LANGUAGE plpgsql
AS $_$
DECLARE
    v_start_time TIMESTAMPTZ;
    v_moved INT := 0;
BEGIN
    v_start_time := clock_timestamp();
    
    IF print_debug THEN
        RAISE NOTICE 'Starting inventory rebalance at %', v_start_time;
    END IF;

    -- Calculate store targets dynamically and rebalance
    WITH store_metrics AS (
        SELECT 
            s.store_id,
            count(DISTINCT c.customer_id) as nearby_customers
        FROM bluebox.store s
        LEFT JOIN bluebox.customer c ON ST_DWithin(s.geog, c.geog, 25000)
        GROUP BY s.store_id
    ),
    totals AS (
        SELECT 
            (SELECT count(*) FROM bluebox.inventory WHERE status_id = 1) as total_inventory,
            (SELECT count(*) FROM bluebox.store) as store_count,
            sum(nearby_customers) as total_customers
        FROM store_metrics
    ),
    dynamic_params AS (
        SELECT 
            -- Floor is 40% of average inventory per store
            (total_inventory / store_count * 0.4)::int as floor_inventory,
            -- Remainder to distribute proportionally
            total_inventory - (total_inventory / store_count * 0.4)::int * store_count as remainder,
            total_customers
        FROM totals
    ),
    store_targets AS (
        SELECT 
            sm.store_id,
            sm.nearby_customers,
            -- Dynamic target: floor + proportional share of remainder
            dp.floor_inventory + (sm.nearby_customers::float / dp.total_customers * dp.remainder)::int as target_inventory,
            (SELECT count(*) FROM bluebox.inventory i WHERE i.store_id = sm.store_id AND i.status_id = 1) as current_inventory
        FROM store_metrics sm, dynamic_params dp
    ),
    -- Stores that need inventory (understocked)
    understocked AS (
        SELECT store_id, target_inventory - current_inventory as need
        FROM store_targets
        WHERE current_inventory < target_inventory * 0.9  -- 10% buffer
    ),
    -- Stores with excess inventory (overstocked)  
    overstocked AS (
        SELECT store_id, current_inventory - target_inventory as excess
        FROM store_targets
        WHERE current_inventory > target_inventory * 1.1  -- 10% buffer
    ),
    -- Available inventory to move (in_circulation, not currently rented)
    moveable_inventory AS (
        SELECT i.inventory_id, i.store_id, i.film_id,
            row_number() OVER (PARTITION BY i.store_id ORDER BY random()) as rn,
            o.excess
        FROM bluebox.inventory i
        INNER JOIN overstocked o ON i.store_id = o.store_id
        LEFT JOIN bluebox.rental r ON i.inventory_id = r.inventory_id 
            AND upper(r.rental_period) IS NULL
        WHERE i.status_id = 1
          AND r.rental_id IS NULL  -- not currently rented
    ),
    -- Only take up to 'excess' items from each overstocked store
    limited_moveable AS (
        SELECT inventory_id, store_id, film_id, rn
        FROM moveable_inventory
        WHERE rn <= excess
    ),
    -- Assign each moveable item to an understocked store (round-robin style)
    understocked_numbered AS (
        SELECT store_id, need, 
            row_number() OVER (ORDER BY need DESC) as store_rank,
            count(*) OVER () as total_understocked
        FROM understocked
    ),
    moves AS (
        SELECT 
            lm.inventory_id,
            lm.store_id as from_store,
            un.store_id as to_store
        FROM (SELECT *, row_number() OVER (ORDER BY random()) as global_rn FROM limited_moveable) lm
        JOIN understocked_numbered un 
            ON ((lm.global_rn - 1) % un.total_understocked) + 1 = un.store_rank
        LIMIT max_moves_per_run
    )
    UPDATE bluebox.inventory i
    SET store_id = m.to_store, last_update = now()
    FROM moves m
    WHERE i.inventory_id = m.inventory_id;

    GET DIAGNOSTICS v_moved = ROW_COUNT;

    IF print_debug THEN
        RAISE NOTICE 'Rebalance complete in % seconds', 
            EXTRACT(EPOCH FROM clock_timestamp() - v_start_time)::numeric(10,2);
        RAISE NOTICE 'Inventory items moved: %', v_moved;
    END IF;

    COMMIT;
END;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.nightly_maintenance(integer, boolean, integer, numeric, boolean)...';END$$;
CREATE PROCEDURE bluebox.nightly_maintenance(IN lost_threshold_days integer DEFAULT 30, IN deactivate_lost_customers boolean DEFAULT true, IN dormant_days integer DEFAULT 180, IN reactivate_pct numeric DEFAULT 0.5, IN print_debug boolean DEFAULT false)
LANGUAGE plpgsql
AS $_$
DECLARE
    v_start_time TIMESTAMPTZ;
    v_step_time TIMESTAMPTZ;
BEGIN
    v_start_time := clock_timestamp();
    
    IF print_debug THEN
        RAISE NOTICE '=== Starting nightly maintenance at % ===', v_start_time;
    END IF;

    -- Step 1: Process lost inventory
    v_step_time := clock_timestamp();
    IF print_debug THEN
        RAISE NOTICE 'Step 1: Processing lost inventory...';
    END IF;
    
    CALL bluebox.process_lost_inventory(
        lost_threshold_days := lost_threshold_days,
        deactivate_customer := deactivate_lost_customers,
        print_debug := print_debug
    );
    
    IF print_debug THEN
        RAISE NOTICE 'Step 1 completed in % ms', EXTRACT(MILLISECOND FROM clock_timestamp() - v_step_time);
    END IF;

    -- Step 2: Update customer activity status
    v_step_time := clock_timestamp();
    IF print_debug THEN
        RAISE NOTICE 'Step 2: Updating customer activity...';
    END IF;
    
    CALL bluebox.update_customer_activity(
        dormant_days := dormant_days,
        reactivate_pct := reactivate_pct,
        print_debug := print_debug
    );
    
    IF print_debug THEN
        RAISE NOTICE 'Step 2 completed in % ms', EXTRACT(MILLISECOND FROM clock_timestamp() - v_step_time);
    END IF;

    -- Step 3: Analyze tables that were modified
    v_step_time := clock_timestamp();
    IF print_debug THEN
        RAISE NOTICE 'Step 3: Analyzing modified tables...';
    END IF;
    
    ANALYZE bluebox.inventory;
    ANALYZE bluebox.customer;
    ANALYZE bluebox.rental;
    ANALYZE bluebox.payment;
    
    IF print_debug THEN
        RAISE NOTICE 'Step 3 completed in % ms', EXTRACT(MILLISECOND FROM clock_timestamp() - v_step_time);
        RAISE NOTICE '=== Nightly maintenance completed in % ms ===', 
            EXTRACT(MILLISECOND FROM clock_timestamp() - v_start_time);
    END IF;

    COMMIT;
END;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.populate_inventory(boolean, boolean)...';END$$;
CREATE PROCEDURE bluebox.populate_inventory(IN clear_existing boolean DEFAULT false, IN print_debug boolean DEFAULT false)
LANGUAGE plpgsql
AS $_$
DECLARE
    v_start_time TIMESTAMPTZ;
    v_tier_a INT := 0;
    v_tier_b INT := 0;
    v_tier_c INT := 0;
    v_tier_d INT := 0;
    v_total INT := 0;
BEGIN
    v_start_time := clock_timestamp();
    
    IF print_debug THEN
        RAISE NOTICE 'Starting inventory population at %', v_start_time;
    END IF;

    -- Optionally clear existing inventory
    IF clear_existing THEN
        IF print_debug THEN
            RAISE NOTICE 'Truncating inventory, rental, and payment tables...';
        END IF;
        -- TRUNCATE is faster and avoids MVCC bloat
        -- CASCADE handles FK dependencies automatically
        TRUNCATE bluebox.inventory RESTART IDENTITY CASCADE;
        COMMIT;
    END IF;

    -- Create tiered inventory
    WITH film_tiers AS (
        SELECT 
            film_id,
            popularity,
            release_date,
            vote_average,
            CASE 
                WHEN popularity >= 100 OR release_date > now() - interval '1 year' THEN 'A'
                WHEN popularity >= 30 OR release_date > now() - interval '3 years' THEN 'B'
                WHEN popularity >= 10 OR vote_average >= 7.0 THEN 'C'
                ELSE 'D'
            END as tier
        FROM bluebox.film
        WHERE film_id NOT IN (SELECT DISTINCT film_id FROM bluebox.inventory)
    ),
    stores_randomized AS (
        SELECT store_id, random() as rnd
        FROM bluebox.store
    ),
    -- Tier A: All stores, 10-14 copies (new/popular)
    tier_a_inventory AS (
        SELECT f.film_id, s.store_id, floor(random() * 5 + 10)::int as copies
        FROM film_tiers f
        CROSS JOIN bluebox.store s
        WHERE f.tier = 'A'
    ),
    -- Tier B: ~60% of stores, 5-7 copies (medium popularity)
    tier_b_inventory AS (
        SELECT f.film_id, s.store_id, floor(random() * 3 + 5)::int as copies
        FROM film_tiers f
        CROSS JOIN stores_randomized s
        WHERE f.tier = 'B' AND s.rnd < 0.6
    ),
    -- Tier C: ~30% of stores, 2-4 copies (decent)
    tier_c_inventory AS (
        SELECT f.film_id, s.store_id, floor(random() * 3 + 2)::int as copies
        FROM film_tiers f
        CROSS JOIN stores_randomized s
        WHERE f.tier = 'C' AND s.rnd < 0.3
    ),
    -- Tier D: ~10% of stores, 1-2 copies (long tail)
    tier_d_inventory AS (
        SELECT f.film_id, s.store_id, floor(random() * 2 + 1)::int as copies
        FROM film_tiers f
        CROSS JOIN stores_randomized s
        WHERE f.tier = 'D' AND s.rnd < 0.1
    ),
    all_inventory AS (
        SELECT * FROM tier_a_inventory UNION ALL
        SELECT * FROM tier_b_inventory UNION ALL
        SELECT * FROM tier_c_inventory UNION ALL
        SELECT * FROM tier_d_inventory
    )
    INSERT INTO bluebox.inventory (film_id, store_id, status_id)
    SELECT film_id, store_id, 1
    FROM all_inventory, generate_series(1, copies);

    COMMIT;

    -- Get counts for reporting
    SELECT count(*) INTO v_total FROM bluebox.inventory;
    
    IF print_debug THEN
        RAISE NOTICE 'Inventory population complete in % seconds', 
            EXTRACT(EPOCH FROM clock_timestamp() - v_start_time)::numeric(10,2);
        RAISE NOTICE 'Total inventory items: %', v_total;
    END IF;
END;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.process_lost_inventory(integer, boolean, boolean)...';END$$;
CREATE PROCEDURE bluebox.process_lost_inventory(IN lost_threshold_days integer DEFAULT 30, IN deactivate_customer boolean DEFAULT true, IN print_debug boolean DEFAULT false)
LANGUAGE plpgsql
AS $_$
DECLARE
    v_lost_count INT;
    v_total_charges NUMERIC(10,2);
    v_lost_status_id INT;
BEGIN
    -- Get the status_id for 'lost'
    SELECT status_id INTO v_lost_status_id 
    FROM bluebox.inventory_status 
    WHERE status_code = 'lost';

    -- Find overdue rentals and process them
    WITH overdue_rentals AS (
        SELECT 
            r.rental_id,
            r.customer_id,
            r.inventory_id,
            lower(r.rental_period) as rental_start,
            f.replacement_cost,
            f.title
        FROM bluebox.rental r
        JOIN bluebox.inventory i ON r.inventory_id = i.inventory_id
        JOIN bluebox.film f ON i.film_id = f.film_id
        WHERE upper(r.rental_period) IS NULL
          AND lower(r.rental_period) < now() - (lost_threshold_days || ' days')::INTERVAL
          AND i.status_id = 1  -- only in_circulation items
    ),
    -- Mark inventory as lost
    mark_lost AS (
        UPDATE bluebox.inventory i
        SET status_id = v_lost_status_id, last_update = now()
        FROM overdue_rentals o
        WHERE i.inventory_id = o.inventory_id
        RETURNING i.inventory_id
    ),
    -- Close the rental
    close_rental AS (
        UPDATE bluebox.rental r
        SET rental_period = tstzrange(lower(rental_period), now()),
            last_update = now()
        FROM overdue_rentals o
        WHERE r.rental_id = o.rental_id
        RETURNING r.rental_id, r.customer_id
    ),
    -- Charge replacement cost
    charge_customer AS (
        INSERT INTO bluebox.payment (customer_id, rental_id, amount, payment_date)
        SELECT 
            o.customer_id,
            o.rental_id,
            COALESCE(o.replacement_cost, 19.99),
            now()
        FROM overdue_rentals o
        RETURNING amount
    ),
    -- Optionally deactivate customer
    deactivate AS (
        UPDATE bluebox.customer c
        SET activebool = FALSE, last_update = now()
        FROM overdue_rentals o
        WHERE c.customer_id = o.customer_id
          AND deactivate_customer = TRUE
        RETURNING c.customer_id
    )
    SELECT count(*), COALESCE(sum(amount), 0)
    INTO v_lost_count, v_total_charges
    FROM charge_customer;

    IF print_debug THEN
        RAISE NOTICE 'Lost inventory processing complete:';
        RAISE NOTICE '  Items marked lost: %', v_lost_count;
        RAISE NOTICE '  Total replacement charges: $%', v_total_charges;
    END IF;

    COMMIT;
END;
$_$;

SET check_function_bodies = true;
