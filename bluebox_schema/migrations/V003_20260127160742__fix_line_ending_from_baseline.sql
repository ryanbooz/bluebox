-- Script generated by Redgate Compare v1.48.1.2539
SET check_function_bodies = false;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Altering bluebox.move_cast_and_crew()...';END$$;
CREATE OR REPLACE PROCEDURE bluebox.move_cast_and_crew()
LANGUAGE plpgsql
AS $_$
BEGIN
	/*
	 * Hopefully not needed anymore, but keeping for safety. At some
	 * points during development films would exist in the staging tables
	 * but not in the main table, which should happen. In most cases I checked
	 * the films weren't of value anyway, and I suspected that IDs changed between
	 * API runs over a few months of development (and not cleaning old record
	 * up along the way)
	 */
	DELETE FROM staging.film_crew WHERE film_id IN (
	SELECT DISTINCT(fc.film_id) FROM
		staging.film_crew fc
		LEFT JOIN bluebox.film f USING (film_id)
		WHERE f.film_id IS NULL 
	);
	
	DELETE FROM staging.film_cast WHERE film_id IN (
	SELECT DISTINCT(fc.film_id) FROM
		staging.film_cast fc
		LEFT JOIN bluebox.film f USING (film_id)
		WHERE f.film_id IS NULL 
	);
	
	/*
	 * Now insert any crew records that don't exist in the main 
	 * film_crew table or film_cast table
	 */
	INSERT INTO bluebox.film_crew (film_id, person_id, department, job)
	SELECT film_id, person_id, fc.department, fc.job FROM staging.film_crew fc
		LEFT JOIN bluebox.film_crew fc1 using(film_id, person_id)
	WHERE fc1.person_id IS NULL AND fc1.film_id IS NULL;
	
	
	INSERT INTO bluebox.film_cast (film_id, person_id, film_character)
	SELECT film_id, person_id, fc.film_character FROM staging.film_cast fc
		LEFT JOIN bluebox.film_cast fc1 using(film_id,person_id)
	WHERE fc1.person_id IS NULL AND fc1.film_id IS NULL;
END;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Altering bluebox.complete_recent_rentals(interval, integer)...';END$$;
CREATE OR REPLACE PROCEDURE bluebox.complete_recent_rentals(IN min_rental_interval interval DEFAULT '24:00:00'::interval, IN max_store_dist integer DEFAULT 25000)
LANGUAGE plpgsql
AS $_$
 DECLARE 
	pid int;
 	rid int;
	cus_id int;
	inv_id int;
	sid int;
	r_sid int;
	tmp_rental_tablename TEXT;
	sqlstr TEXT;
 BEGIN
	 
	SELECT pg_backend_pid() INTO pid; 
	
	tmp_rental_tablename = 'tmp_open_rentals_' || pid::TEXT;
 
	RAISE NOTICE '%',tmp_rental_tablename;

	EXECUTE FORMAT($$CREATE TEMPORARY TABLE %1$I (
		rental_id int,
		customer_id int,
		inventory_id int,
		store_id int
	);$$,tmp_rental_tablename);


	EXECUTE FORMAT($$INSERT INTO %1$I 
	SELECT rental_id, customer_id, inventory_id, store_id FROM bluebox.rental WHERE upper(rental_period) IS NULL 
		AND lower(rental_period) < now()-%2$L::INTERVAL;$$,tmp_rental_tablename,min_rental_interval);


	EXECUTE 'ANALYZE ' || tmp_rental_tablename;
	-- sample 0.01% of the rows from available customers for the given day 
	-- loop over them and

	FOR rid,cus_id,inv_id,r_sid IN EXECUTE FORMAT('SELECT rental_id, customer_id, inventory_id,store_id FROM %1$I TABLESAMPLE bernoulli(random_between(10,20,1))',tmp_rental_tablename)
 	LOOP
	 	-- update the rental end period to be between 16 hours and 4 days from initial rental.
	 	-- end the rental between 16 hours and 96 hours after start
	 	UPDATE bluebox.rental SET rental_period = tstzrange(lower(rental_period), (lower(rental_period) + (random_between(57600,345600)::TEXT || ' seconds')::INTERVAL))
	 	WHERE rental_id = rid;
	 
	 	-- Find a store that's within the specified distance. This will give some randomness
	 	-- to the rental locations for each customer
	 	WITH store_inv AS (
			SELECT s.store_id, ST_Distance(s.geog,cus.geog) dist FROM bluebox.store s,
				bluebox.customer cus
			WHERE ST_DWithin(s.geog,cus.geog,max_store_dist)
				AND cus.customer_id = cus_id
			ORDER BY random()
			LIMIT 1
		)
		SELECT store_id INTO sid FROM store_inv;
	
		IF sid IS NULL THEN
			sid := r_sid;
		END IF;
	
        UPDATE bluebox.inventory SET store_id = sid
		WHERE inventory_id = inv_id; 
		
		COMMIT;
		
		sid:=NULL;
	
		CALL bluebox.insert_single_payment(rid);
		
 	end LOOP;	 
	 
 	EXECUTE 'DROP TABLE ' || tmp_rental_tablename;


 END;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Altering bluebox.add_new_inventory()...';END$$;
CREATE OR REPLACE PROCEDURE bluebox.add_new_inventory()
LANGUAGE plpgsql
AS $_$
DECLARE
	storeid int;
	maxrd date;
BEGIN 
	/*
 * This query was a first attempt to fill the inventory
 * table with some kind relevance - ie. newer, popular movies
 * get more copies than older or less popular movies.
 */
	FOR storeid IN SELECT store_id FROM bluebox.store
	LOOP
		SELECT max(release_date) INTO maxrd FROM bluebox.inventory i
			JOIN bluebox.film f USING(film_id)
		WHERE store_id=storeid;
		
		WITH inventory_tmp (film_id, popularity, total_i, release_date) AS (
			SELECT f.film_id, f.popularity, CASE
				WHEN f.popularity <= 20 THEN ARRAY[0,3]
				WHEN f.popularity BETWEEN 20 AND 35 THEN ARRAY[0,5]
				WHEN f.popularity BETWEEN 35 AND 75 THEN ARRAY[2,6]
				WHEN f.popularity BETWEEN 75 AND 100 THEN ARRAY[5,8]
				WHEN f.popularity BETWEEN 100 AND 500 THEN ARRAY[8,12]
				WHEN f.popularity >500 THEN ARRAY[12,20]
				END,
				release_date
			FROM bluebox.film f
				WHERE film_id NOT IN (SELECT count(DISTINCT film_id) FROM bluebox.inventory WHERE store_id=storeid)
					AND release_date > maxrd
		),
		adjusted_inventory AS (
			SELECT it.film_id, it.popularity, 
			CASE 
				WHEN release_date > now()-'1 year'::INTERVAL THEN it.total_i
				WHEN release_date BETWEEN now()-'3 years'::INTERVAL AND now()-'1 year'::INTERVAL THEN
					array_agg(greatest(val-1,0))
				WHEN release_date BETWEEN now()-'4 years'::INTERVAL AND now()-'3 year'::INTERVAL THEN
					array_agg(greatest(val-2,0))
				WHEN release_date < now()-'4 years'::INTERVAL THEN
					array_agg(greatest(val-3,0))
			END AS total_i
			FROM inventory_tmp it, unnest(it.total_i) AS val
			GROUP BY it.film_id, it.popularity, it.release_date, it.total_i
		)
--		SELECT * FROM adjusted_inventory;
		INSERT INTO bluebox.inventory (film_id, store_id)
		SELECT film_id, storeid
		FROM adjusted_inventory ai, random_between(ai.total_i[1],ai.total_i[2]) x(i), generate_series(1,x.i)
		WHERE x.i>0;

	COMMIT;
	END LOOP;
END;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Altering bluebox.update_movie_rating()...';END$$;
CREATE OR REPLACE PROCEDURE bluebox.update_movie_rating()
LANGUAGE plpgsql
AS $_$
BEGIN 
	UPDATE bluebox.film SET rating = y.mpaa::mpaa_rating
	FROM (
		SELECT film_id, trim(x->>'certification') mpaa, x->>'type' type FROM staging.release_date rd, jsonb_array_elements(releases) x
		WHERE x->>'iso_3166_1' = 'US'
		--AND (x->>'type')::int = 3
		AND (x->>'certification') != ''
		AND film_id IN (SELECT film_id FROM film WHERE rating IS NULL)	
		) y 
	WHERE film.film_id = y.film_id;
END;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Altering public._group_concat(text, text)...';END$$;
CREATE OR REPLACE FUNCTION public._group_concat(IN text, IN text)
RETURNS text
LANGUAGE sql
IMMUTABLE
AS $_$
SELECT CASE
  WHEN $2 IS NULL THEN $1
  WHEN $1 IS NULL THEN $2
  ELSE $1 || ', ' || $2
END
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Altering public.last_day(timestamp with time zone)...';END$$;
CREATE OR REPLACE FUNCTION public.last_day(IN timestamp with time zone)
RETURNS date
LANGUAGE sql
IMMUTABLE
AS $_$
  SELECT CASE
    WHEN EXTRACT(MONTH FROM $1) = 12 THEN
      (((EXTRACT(YEAR FROM $1) + 1) operator(pg_catalog.||) '-01-01')::date - INTERVAL '1 day')::date
    ELSE
      ((EXTRACT(YEAR FROM $1) operator(pg_catalog.||) '-' operator(pg_catalog.||) (EXTRACT(MONTH FROM $1) + 1) operator(pg_catalog.||) '-01')::date - INTERVAL '1 day')::date
    END
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Altering public.last_updated()...';END$$;
CREATE OR REPLACE FUNCTION public.last_updated()
RETURNS trigger
LANGUAGE plpgsql
AS $_$
BEGIN
    NEW.last_update = CURRENT_TIMESTAMP;
    RETURN NEW;
END $_$;

SET check_function_bodies = true;
