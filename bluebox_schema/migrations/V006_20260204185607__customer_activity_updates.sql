-- Script generated by Redgate Compare v1.48.1.2539
SET check_function_bodies = false;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.customer_status_log...';END$$;
CREATE TABLE bluebox.customer_status_log (
    log_id bigint NOT NULL GENERATED ALWAYS AS IDENTITY,
    customer_id integer NOT NULL,
    status_date timestamp with time zone NOT NULL DEFAULT now(),
    status text NOT NULL,
    reason_code text NOT NULL,
    notes text,
    rental_id bigint
);
ALTER TABLE bluebox.customer_status_log ADD CONSTRAINT customer_status_log_pkey PRIMARY KEY (log_id);

-- Populate the table with existing customers
INSERT INTO bluebox.customer_status_log (customer_id, status_date, status, reason_code, notes)
SELECT 
    customer_id,
    create_date::timestamptz,
    'active',
    'signup',
    'Backfilled from existing customer data'
FROM bluebox.customer;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Dropping bluebox.add_new_inventory()...';END$$;
DROP PROCEDURE bluebox.add_new_inventory();


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.log_customer_status(integer, text, text, text, bigint, timestamp with time zone)...';END$$;
CREATE FUNCTION bluebox.log_customer_status(IN p_customer_id integer, IN p_status text, IN p_reason_code text, IN p_notes text DEFAULT NULL::text, IN p_rental_id bigint DEFAULT NULL::bigint, IN p_status_date timestamp with time zone DEFAULT now())
RETURNS bigint
LANGUAGE plpgsql
AS $_$
DECLARE
    v_log_id bigint;
BEGIN
    INSERT INTO bluebox.customer_status_log 
        (customer_id, status_date, status, reason_code, notes, rental_id)
    VALUES 
        (p_customer_id, p_status_date, p_status, p_reason_code, p_notes, p_rental_id)
    RETURNING log_id INTO v_log_id;
    
    RETURN v_log_id;
END;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.idx_csl_status...';END$$;
CREATE INDEX idx_csl_status ON bluebox.customer_status_log USING btree (status, status_date);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.idx_csl_date...';END$$;
CREATE INDEX idx_csl_date ON bluebox.customer_status_log USING btree (status_date);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.idx_csl_customer...';END$$;
CREATE INDEX idx_csl_customer ON bluebox.customer_status_log USING btree (customer_id, status_date DESC);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.customer_status_log.customer_status_log_customer_id_fkey...';END$$;
ALTER TABLE bluebox.customer_status_log ADD CONSTRAINT customer_status_log_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES bluebox.customer (customer_id);


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.process_lost_rentals(interval, boolean, boolean)...';END$$;
CREATE PROCEDURE bluebox.process_lost_rentals(IN p_lost_after interval DEFAULT '30 days'::interval, IN p_suspend_customer boolean DEFAULT true, IN p_print_debug boolean DEFAULT false)
LANGUAGE plpgsql
AS $_$
DECLARE
    v_lost_count int;
    v_payments_created int;
    v_suspended_count int;
BEGIN
    WITH lost_rentals AS MATERIALIZED (
        SELECT 
            r.rental_id,
            r.customer_id,
            r.inventory_id,
            r.store_id,
            lower(r.rental_period) as rental_start,
            now() as loss_date
        FROM bluebox.rental r
        WHERE upper(r.rental_period) IS NULL
          AND lower(r.rental_period) < now() - p_lost_after
    ),
    
    closed_rentals AS (
        UPDATE bluebox.rental r
        SET rental_period = tstzrange(lower(r.rental_period), lr.loss_date)
        FROM lost_rentals lr
        WHERE r.rental_id = lr.rental_id
        RETURNING r.rental_id, r.inventory_id, r.customer_id, lr.loss_date
    ),
    
    lost_inventory AS (
        UPDATE bluebox.inventory i
        SET status_id = 2,  -- 'lost'
            last_update = now()
        FROM closed_rentals cr
        WHERE i.inventory_id = cr.inventory_id
        RETURNING i.inventory_id, i.film_id
    ),
    
    payment_info AS (
        SELECT 
            cr.rental_id,
            cr.customer_id,
            cr.loss_date as payment_date,
            bluebox.get_replacement_cost(li.film_id) as amount
        FROM closed_rentals cr
        JOIN lost_inventory li ON li.inventory_id = cr.inventory_id
    ),
    
    created_payments AS (
        INSERT INTO bluebox.payment (customer_id, rental_id, amount, payment_date)
        SELECT customer_id, rental_id, amount, payment_date
        FROM payment_info
        RETURNING payment_id, rental_id, customer_id
    ),
    
    -- Suspend customers who lost items
    suspend_customers AS (
        UPDATE bluebox.customer c
        SET activebool = FALSE, last_update = now()
        FROM created_payments cp
        WHERE c.customer_id = cp.customer_id
          AND p_suspend_customer
        RETURNING c.customer_id, cp.rental_id
    ),
    
    -- Log the suspensions
    log_suspensions AS (
        INSERT INTO bluebox.customer_status_log (customer_id, status, reason_code, rental_id, notes)
        SELECT customer_id, 'suspended', 'lost_item', rental_id, 'Item not returned, charged replacement cost'
        FROM suspend_customers
        RETURNING log_id
    )
    
    SELECT 
        (SELECT count(*) FROM closed_rentals),
        (SELECT count(*) FROM created_payments),
        (SELECT count(*) FROM log_suspensions)
    INTO v_lost_count, v_payments_created, v_suspended_count;
    
    IF p_print_debug THEN
        RAISE NOTICE 'Marked % rentals as lost, created % payments, suspended % customers', 
            v_lost_count, v_payments_created, v_suspended_count;
    END IF;
    
    COMMIT;
END;
$_$;


DO LANGUAGE plpgsql $$BEGIN RAISE NOTICE 'Creating bluebox.update_customer_activity(integer, numeric, boolean)...';END$$;
CREATE PROCEDURE bluebox.update_customer_activity(IN dormant_days integer DEFAULT 180, IN reactivate_pct numeric DEFAULT 0.5, IN print_debug boolean DEFAULT false)
LANGUAGE plpgsql
AS $_$
DECLARE
    v_deactivated INT;
    v_reactivated INT;
BEGIN
    -- Step 1: Deactivate customers who haven't rented in dormant_days
    -- and don't have any open rentals
    WITH customers_to_deactivate AS (
        SELECT c.customer_id
        FROM bluebox.customer c
        LEFT JOIN bluebox.rental r ON c.customer_id = r.customer_id
        WHERE c.activebool = TRUE
        GROUP BY c.customer_id
        HAVING 
            (MAX(lower(r.rental_period)) IS NULL 
             OR MAX(lower(r.rental_period)) < now() - (dormant_days || ' days')::INTERVAL)
            AND COUNT(*) FILTER (WHERE upper(r.rental_period) IS NULL) = 0
    ),
    do_deactivate AS (
        UPDATE bluebox.customer c
        SET activebool = FALSE, last_update = now()
        FROM customers_to_deactivate ctd
        WHERE c.customer_id = ctd.customer_id
        RETURNING c.customer_id
    ),
    log_deactivations AS (
        INSERT INTO bluebox.customer_status_log (customer_id, status, reason_code, notes)
        SELECT customer_id, 'inactive', 'inactivity', 
               format('No rental in %s days', dormant_days)
        FROM do_deactivate
    )
    SELECT count(*) INTO v_deactivated FROM do_deactivate;

    -- Step 2: Randomly reactivate a small percentage of inactive customers
    -- Simulates win-back marketing campaigns
    WITH random_reactivate AS (
        SELECT customer_id
        FROM bluebox.customer
        WHERE activebool = FALSE
          AND random() < (reactivate_pct / 100.0)
    ),
    do_reactivate AS (
        UPDATE bluebox.customer c
        SET activebool = TRUE, last_update = now()
        FROM random_reactivate rr
        WHERE c.customer_id = rr.customer_id
        RETURNING c.customer_id
    ),
    log_reactivations AS (
        INSERT INTO bluebox.customer_status_log (customer_id, status, reason_code, notes)
        SELECT customer_id, 'active', 'winback', 'Random reactivation (simulated marketing)'
        FROM do_reactivate
    )
    SELECT count(*) INTO v_reactivated FROM do_reactivate;

    IF print_debug THEN
        RAISE NOTICE 'Customer activity update complete:';
        RAISE NOTICE '  Deactivated (inactivity): %', v_deactivated;
        RAISE NOTICE '  Reactivated (win-back): %', v_reactivated;
    END IF;

    COMMIT;
END;
$_$;

SET check_function_bodies = true;
